{ config, options, lib, pkgs, ... }:
with lib;
let
  cfg = config.age;

  # we need at least rage 0.5.0 to support ssh keys
  rage =
    if lib.versionOlder pkgs.rage.version "0.5.0"
    then pkgs.callPackage ../pkgs/rage.nix { }
    else pkgs.rage;
  ageBin = config.age.ageBin;
  systemdCredsBin = config.age.systemdCredsBin;

  identities = builtins.concatStringsSep " " (map (path: "-i ${path}") cfg.identityPaths);

  installSecret = secretType: ''
  set -xe
  echo "[agenix] Installing secret ${secretType.name}"
  _truePath="${secretType.path}"
  TMP_FILE="$_truePath.tmp"
  mkdir -p "$(dirname "$_truePath")"
  (
    umask u=r,g=,o=
    test -f "${secretType.file}" || echo '[agenix] WARNING: encrypted file ${secretType.file} does not exist!'
    test -d "$(dirname "$TMP_FILE")" || echo "[agenix] WARNING: $(dirname "$TMP_FILE") does not exist!"
    ${ageBin} --decrypt ${identities} -o - ${secretType.file} | ${systemdCredsBin} ${cfg.systemd-creds-flags} encrypt --name="${secretType.name}" - - > "$TMP_FILE" || echo "[agenix] Something went wrong!"
  )
  chmod 600 "$TMP_FILE"
  chown 0:0 "$TMP_FILE"
  mv -f "$TMP_FILE" "$_truePath"
  '';

  secretType = types.submodule ({ config, ... }: {
    options = {
      name = mkOption {
        type = types.str;
        default = config._module.args.name;
        description = ''
          Name of the file used in ''${cfg.secretsDir}
        '';
      };
      file = mkOption {
        type = types.path;
        description = ''
          Age file the secret is loaded from.
        '';
      };
      path = mkOption {
        type = types.str;
        default = "${cfg.secretsDir}/${config.name}";
        description = ''
          Path where the decrypted secret is installed.
        '';
      };
      unitConfig = mkOption {
        type = types.attrs;
        default = {};
        description = ''
          Attributes of the systemd unit that will install this secret.
          Useful to set reverse dependencies (WantedBy=, Before=).
        '';
        example = ''
        {
          serviceConfig = {
            wantedBy = [ "nginx.service" ];
            before = [ "nginx.service" ];
          };
        }
        '';
      };

      # Options below this line are meant to be read-only.

      serviceNameShort = mkOption {
        type = types.str;
        default = "agenix-systemd-${config.name}";
        description = ''
          Name of the systemd service installing this secret, without
          the <literal>.service</literal> extension.
        '';
        example = "agenix-systemd-service_password";
      };
      serviceName = mkOption {
        type = types.str;
        default = "${config.serviceNameShort}.service";
        description = ''
          Name of the systemd service installing this
          secret. Autogenerated, you can use this to depend on this
          secret being installed.
        '';
        example = "agenix-systemd-service_password.service";
      };
      credentialConfig = mkOption {
        type = types.str;
        default = "${config.name}:${config.path}";
        description = ''
          String to pass to
          <literal>LoadCredentialEncrypted=</literal> to enable a
          service to depend on this secret.
        '';
        example = "service_password:/var/run/agenix/service_password";
      };
      credentialPath = mkOption {
        type = types.str;
        default = "$CREDENTIALS_DIRECTORY/${config.name}";
        description = ''
          Path to the decrypted credential file, usable inside a
          service definition. Always under
          <literal>$CREDENTIALS_DIRECTORY</literal>.
        '';
        example = "$CREDENTIALS_DIRECTORY/service_password";
      };
      unitTemplate = mkOption {
        type = types.anything;
        default = {
          requires = [ config.serviceName ];
          after = [ config.serviceName ];
          serviceConfig = {
            LoadCredentialEncrypted = config.credentialConfig;
          };
        };
        description = ''
          Template of a service config that enables a service to depend on this secret.

          May be used as:
          <literal>
            systemd.services.nginx = config.age.mysecret.unitTemplate;
          </literal>.

          Do not use with //, use <literal>wrapUnit</literal> instead.
        '';
      };
      wrapUnit = mkOption {
        type = types.anything;
        default = x: lib.recursiveUpdate x config.unitTemplate;
        description = ''
          Function that transforms a systemd unit definition into one that will be able to access this secret.
        '';
      };
    };
  });

  mkService = _: secretType: lib.nameValuePair secretType.serviceNameShort (
    lib.recursiveUpdate {
      enable = true;
      description = "Install secret: ${secretType.name}";
      script = installSecret secretType;
      restartIfChanged = true;
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
      };
    } secretType.unitConfig);

  allServices = lib.mapAttrs' mkService cfg.secrets;
in {
  options.age = {
    ageBin = mkOption {
      type = types.str;
      default = "${rage}/bin/rage";
      description = ''
        The age executable to use.
      '';
    };
    systemdCredsBin = mkOption {
      type = types.str;
      default = "${pkgs.systemd}/bin/systemd-creds";
      description = ''
        The systemd-creds executable to use.
      '';
    };
    systemd-creds-flags = mkOption {
      type = types.str;
      default = "";
      description = ''
        Extra flags to systemd-creds.
      '';
      example = "-H";
    };
    secrets = mkOption {
      type = types.attrsOf secretType;
      default = { };
      description = ''
        Attrset of secrets.
      '';
    };
    secretsDir = mkOption {
      type = types.path;
      default = "/run/agenix";
      description = ''
        Folder where secrets are symlinked to
      '';
    };
    identityPaths = mkOption {
      type = types.listOf types.path;
      default =
        if config.services.openssh.enable then
          map (e: e.path) (lib.filter (e: e.type == "rsa" || e.type == "ed25519") config.services.openssh.hostKeys)
        else [ ];
      description = ''
        Path to SSH keys to be used as identities in age decryption.
      '';
    };
  };

  config = mkIf (cfg.secrets != { }) {
    assertions = [{
      assertion = cfg.identityPaths != [ ];
      message = "age.identityPaths must be set.";
    }];

    systemd.services = allServices;
  };
}
